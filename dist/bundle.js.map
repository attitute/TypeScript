{"version":3,"file":"bundle.js","sources":["../src/index.ts"],"sourcesContent":["\r\n\r\n// 接口可以被类实现 把接口用在类上\r\ninterface Speakable { // 接口中的内容都是抽象，没有具体的实现\r\n    name: string,\r\n    speak(): void // 描述类的原型方法 ，void 表示不关心方法的返回值\r\n}\r\n\r\ninterface ChineseSpeakable {\r\n    speakChinese():void\r\n}\r\n\r\n// 两个接口不能有冲突\r\nclass Speak implements Speakable,ChineseSpeakable {\r\n    speakChinese(): void {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n    speak(): number {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n    name!: string;\r\n    \r\n}\r\n\r\n\r\n// 类 抽象类 不能被实例化 只有抽象类可以标记abstract 标记abstract才需要子类实现\r\nabstract class Animal { // 抽象类中可以包含抽象方法和抽象属性\r\n    abstract name:string // 抽象没有实现 \r\n    eat(){ // 有实现（是否赋值）\r\n        console.log('eat')\r\n    }\r\n}\r\n\r\nclass Tom extends Animal {\r\n    name!: string;\r\n    \r\n}\r\n\r\n// 可以描述对象 函数 类 类的实例\r\n\r\n\r\n// <T>就是泛型 函数调用时传入类型 \r\nclass Person {\r\n    constructor(public name:string){\r\n        this.name = name\r\n    }\r\n}\r\n\r\ninterface Clazz<T> {\r\n    new (name:string):T\r\n}\r\n\r\nfunction createInstance<T> (clazz:Clazz<T>, name:string){\r\n    return new clazz(name)\r\n}\r\n\r\nlet r = createInstance<Person>(Person, 'me')\r\n\r\n\r\n\r\n\r\n\r\nexport {}"],"names":[],"mappings":";;;IAYA;IA0BA;IAGA;IACA;QACI,YAAmB,IAAW;YAAX,SAAI,GAAJ,IAAI,CAAO;YAC1B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAA;SACnB;KACJ;IAMD,wBAA4B,KAAc,EAAE,IAAW;QACnD,OAAO,IAAI,KAAK,CAAC,IAAI,CAAC,CAAA;IAC1B,CAAC;IAED,IAAI,CAAC,GAAG,cAAc,CAAS,MAAM,EAAE,IAAI,CAAC;;;;;;"}